% Generated by roxygen2 (4.0.0): do not edit by hand
\name{swcGetMapping}
\alias{swcGetMapping}
\title{Compute a matching table between two lists of municipality IDs}
\usage{
swcGetMapping(swc = swcGetData(), ids.from, ids.to)
}
\arguments{
\item{swc}{Data as read by the function \code{swcReadData}, defaults to
\code{swcGetData()}.}

\item{ids.from}{A list of "source" municipality IDs, preferably a factor}

\item{ids.to}{A list of "target" municipality IDs, preferably a factor}
}
\value{
A data frame with columns prefixed by \code{from.} and \code{to} that
  represents the computed match.  The municipality IDs are stored in the
  columns \code{from.mId} and \code{to.mId}.  The columns
  \code{from.MergeType} and \code{to.MergeType} contain \code{valid} if
  the municipality is contained in both the input and the mapping table,
  \code{missing} if the municipality is missing from the input, and
  \code{extra} if the municipality is in the input but not in the mapping
  table; most columns are \code{NA} for such rows.  In addition, the column
  \code{MergeType} offers a summary of the "from" and "to" status: Rows with
  values other than \code{"valid"} or \code{"missing"} should be examined.
}
\description{
For two lists of Swiss municipality IDs at any two points in time, this
function creates a data frame with two columns where each row represents
a match between municipality IDs.  This can be used as an intermediate
table for merging two data sets with municipality identifiers taken at
different, possibly unknown, points in time.
}
\details{
It is advisable to use factors as list of municipality IDs.  By that,
comparisons and merges for municipality IDs are automatically checked for
compatibility.

Note that the "from" list must be from an earlier time than the "to" list.
Trying to compute the mapping the other way round results in an error.
This is intentional: As municipalities are usually merged, it makes sense
to use the most recent data set as target for the mapping.  This can also be
a file with suitable geometries to allow for visualization.
}
\examples{
data(SwissPop)
data(SwissBirths)

# Show mismatch of municipality IDs:
ids.from <- with(SwissPop, MunicipalityID)
ids.to <- with(SwissBirths, MunicipalityID)
setdiff(ids.from, ids.to)
setdiff(ids.to, ids.from)

# Compute mapping and count non-matching municipality IDs:
mapping <- swcGetMapping(ids.from=ids.from, ids.to=ids.to)
with(mapping, sum(mapping$mIdAsNumber.from != mapping$mIdAsNumber.to))

# These should be looked at in some detail, and fixed manually:
subset(mapping, !(MatchType \%in\% c("valid", "missing")))

# Test for injectivity. The result shows that the mapping is almost injective,
# only one "from" commune is mapped to more than one other "to" commune.
# This situation requires further examination.
mapping.dupes <- subset(mapping, duplicated(mIdAsNumber.from))
(noninjective.mapping <- subset(
  mapping, mIdAsNumber.from \%in\% mapping.dupes$mIdAsNumber.from))

# Simple treatment (just for this example): Remove duplicates, and use only
# valid matches:
cleaned.mapping <- subset(mapping,
                          !duplicated(mIdAsNumber.from) & MatchType == "valid")

# Now merge the two datasets based on the mapping table:
SwissPop.1970 <- subset(SwissPop, Year == "1970")
SwissPopMapping.1970 <- merge(SwissPop.1970,
                              cleaned.mapping[, c("mId.from", "mId.to")],
                              by.x = "MunicipalityID", by.y = "mId.from")

# Datasets from the "from" table must be suitably aggregated.  For the given 
# case of population totals we use the sum.
SwissPopMapping.1970.agg <- plyr::ddply(
  SwissPopMapping.1970, c("mId.to", "HouseholdSize"),
  plyr::summarize, Households=sum(Households))
with(SwissPopMapping.1970.agg, stopifnot(
  length(unique(mId.to)) * length(levels(HouseholdSize)) ==
    length(mId.to)))

# The aggregated "from" dataset now can be merged with the "to" dataset:
SwissBirths.1970 <- subset(SwissBirths, Year == "1970")
SwissPopBirths.1970 <- merge(SwissPopMapping.1970.agg, SwissBirths.1970,
                             by.x = "mId.to", by.y = "MunicipalityID")

# Some more communes are still missing from the 1970 statistics, although
# the matches are valid:
subset(mapping, mIdAsNumber.to \%in\% setdiff(
  SwissPopMapping.1970.agg$mId.to, SwissBirths.1970$MunicipalityID))[,
    c("mId.from", "mShortName.from", "MatchType")]

# The "from" list must be from an earlier time than the "to" list.
try(swcGetMapping(ids.from=ids.to, ids.to=ids.from))
}

